#!/usr/bin/env python3

"""
This program manages two versions of a config file,
a template suitable for version control and publication,
and a live version that contains secrets.
You can initialize such a link by starting with either of the files
and using this program to derive the other and establish a link from the live file to the template.

The template file *must* be in a git repo.
This program uses the git object store behind the scenes to facilitate 3-way merges of changes.
Note that secret values are never added into the git object store;
multiple versions of the template are stored and retrieved.
It's important if the live file is every distributed to another machine
that its corresponding template (mentioned by the template-object-hash declaration)
be fully committed and pushed in the git repo.
If the live file is never distributed, then it's not important to manually commit the template file;
this program will keep copies of any version of the template file in hidden git metadata
so that references never get broken by the git garbage collector.

If you're starting with a live file that contains secrets, and you want to factor/generalize/sanitize
it into something suitable for version control and/or publication,
make a sanitized copy of the file with the secret values replaced by {{variable-name}} references,
and put the following comments at the top of the file (within the first 5 lines):

# config-with-secrets:template-object-hash: {{hash}}

Use whatever #comment or //comment style is appropriate for your syntax.
If {{ and }} are already likely to appear in your syntax, use whatever prefix and suffix you like,
e.g. $(hash), %%hash%%, --->hash<---, etc.
This will establish the template substitution pattern for the rest of the variables in the file.
If a comment terminator is necessary, e.g. for /* */ style comments,
be sure to put a space between the hash suffix and the comment terminator, e.g. {{hash}} */, not {{hash}}*/.
Spaces are allowed in start-of-comment markers (e.g. the space in '# ')
but not in variable prefix/suffix or comment terminators.

If you're starting with the template, you can instantiate it by calling:

    config-with-secrets path/to/template path/to/live

and the program will prompt you to paste in the values of all the template parameters.
If you started with a live version and derived the template from it,
insert the first line into the live version so that the {{hash}} variable reference is in there,
and then run the above command to create a link between the live version and the template.
"""

import sys, os, subprocess
import io
import getpass
import re

def main():
    import argparse
    parser = argparse.ArgumentParser()
    parser.add_argument("template", help="the template in a git repo")
    parser.add_argument("live", help="the live file containing secrets")
    args = parser.parse_args()

    # Files gotta exist
    template_stat = os.stat(args.template)
    live_stat = os.stat(args.live)

    # Ensure template is in a git repo.
    try:
        repo_root = subprocess.run(
            ["git", "rev-parse", "--show-toplevel"],
            user=template_stat.st_uid, group=template_stat.st_gid,
            cwd=os.path.dirname(os.path.abspath(args.template)),
            check=True, stdout=subprocess.PIPE,
        ).stdout.decode("utf8").rstrip()
    except subprocess.CalledProcessError:
        sys.exit("ERROR: template file must be in a git repo: " + args.template)
    def git(*args, **kwargs):
        cmd = ["git"]
        cmd.extend(args)
        return subprocess.run(cmd,
            cwd=repo_root, stdout=subprocess.PIPE, check=True,
            user=template_stat.st_uid, group=template_stat.st_gid,
            **kwargs,
        ).stdout.decode("utf8")

    # Read input files.
    template_contents = read_file(args.template)
    live_contents = read_file(args.live)
    syntax = parse_syntax(template_contents, args.template)
    split_new_template = split_template(template_contents, syntax, args.template)

    # Load base template.
    base_hash = parse_hash(live_contents, syntax, args.live)
    if len(base_hash) == 0:
        # Hasn't been initialized yet.
        template_base_contents = template_contents
        split_base_template = split_new_template
    else:
        # Load the previous template.
        effective_file_name = base_hash + "^{blob}"
        template_base_contents = git("cat-file", "-p", effective_file_name)
        base_syntax = parse_syntax(template_base_contents, effective_file_name)
        split_base_template = split_template(template_base_contents, base_syntax, effective_file_name)

    # Get values from live file.
    values = parse_live(live_contents, split_base_template, args.live)

    # Get any new values from user input.
    new_names = split_new_template[1::2]
    for name in sorted(set(new_names) - set(values.keys())):
        values[name] = getpass.getpass("{}> ".format(name))

    # Save template.
    template_relative_path = os.path.relpath(args.template, repo_root)
    object_name = git("hash-object", "-w", template_relative_path).rstrip()
    values["hash"] = object_name
    # TODO: write it into a secret ref in case it's not part of a commit.

    # Instantiate new template.
    new_contents_buf = io.StringIO()
    new_contents_buf.write(split_new_template[0])
    for name, literal_segment in zip(*[iter(split_new_template[1:])]*2):
        new_contents_buf.write(values[name])
        new_contents_buf.write(literal_segment)
    new_contents = new_contents_buf.getvalue()

    # Write to disk.
    with open(args.live + ".tmp", "w") as f:
        os.chown(args.live + ".tmp", live_stat.st_uid, live_stat.st_gid)
        os.chmod(args.live + ".tmp", live_stat.st_mode)
        f.write(new_contents)
    os.rename(args.live + ".tmp", args.live)


def parse_syntax(contents, file_for_error_reporting):
    for line in contents.splitlines()[:5]:
        match = re.match(r'^(?:.*)config-with-secrets:template-object-hash: (\S+)hash(\S+)(?:\s+.*)?$', line)
        if match == None: continue
        prefix, suffix = match.groups()
        return prefix, suffix
    sys.exit("ERROR: file does not appear to be a config-with-secrets template: " + file_for_error_reporting)

def parse_hash(contents, syntax, file_for_error_reporting):
    # Use the expected long prefix as an early assert that the user passed in the right file.
    prefix = "config-with-secrets:template-object-hash: "
    try:
        start = contents.index(prefix) + len(prefix)
    except ValueError:
        sys.exit("ERROR: file does not appear to be a config-with-secrets live file: " + file_for_error_reporting)
    end = re.compile(r'\s|$').search(contents, start).span()[0]
    value = contents[start:end]
    if re.match(r'^[0-9a-f]{40}$', value) != None:
        return value
    if value == syntax[0] + "hash" + syntax[1]:
        # live file is not yet initialized.
        return ""
    sys.exit("ERROR: file does not appear to be a config-with-secrets live file, invalid hash format: " + file_for_error_reporting)

def split_template(contents, syntax, file_for_error_reporting):
    slices = []
    cursor = 0
    def error(message):
        report_error_and_crash(file_for_error_reporting, contents, cursor, message)
    while True:
        try:
            slice_end = contents.index(syntax[0], cursor)
        except ValueError:
            break
        slices.append(contents[cursor:slice_end])
        cursor = slice_end # error reporting from here
        name_start = slice_end + len(syntax[0])
        try:
            name_end = contents.index(syntax[1], name_start)
        except ValueError:
            error("found " + syntax[0] + " without matching " + syntax[1])
        name = contents[name_start:name_end]
        if re.search(r"\s+", name) != None:
            error("found " + syntax[0] + " without matching " + syntax[1])
        slices.append(name)
        cursor = name_end + len(syntax[1])
    slices.append(contents[cursor:])
    return slices

def parse_live(contents, split_template, file_for_error_reporting):
    cursor = 0
    def error(message):
        report_error_and_crash(file_for_error_reporting, contents, cursor, message)
    def consume_literal_segment(expected_segment):
        nonlocal cursor
        found_segment = contents[cursor:cursor+len(expected_segment)]
        if found_segment != expected_segment:
            error("template does not match live file")
        cursor += len(expected_segment)
    consume_literal_segment(split_template[0])
    values = {}
    for name, literal_segment in zip(*[iter(split_template[1:])]*2):
        try:
            value_end = contents.index(literal_segment[0], cursor)
        except ValueError:
            error("found EOF, expected end of secret value")
        value = contents[cursor:value_end]
        if "\n" in value:
            error("found end of line, expected end of secret value")
        cursor = value_end

        try:
            existing_value = values[name]
        except KeyError:
            values[name] = value
        else:
            if existing_value != value:
                error("conflicting value given for: " + name)

        consume_literal_segment(literal_segment)
    if cursor < len(contents):
        error("template does not match live file")
    return values


def report_error_and_crash(file_for_error_reporting, contents, cursor, message):
    context_line_start = contents.rfind("\n", 0, cursor) + 1
    try:
        context_line_end = contents.index("\n", context_line_start)
    except ValueError:
        context_line_end = len(contents)
    sys.exit("{}:{}: ERROR: {}\n{}\n{}^".format(
        file_for_error_reporting,
        len(contents[:cursor].split("\n")),
        message,
        contents[context_line_start:context_line_end],
        " " * (cursor - context_line_start),
    ))

def read_file(path):
    with open(path) as f:
        return f.read()

if __name__ == "__main__":
    main()
